# diagnose_pipeline.py
"""
Diagnostic script for pipeline matching failures.
Loads the final diagnostic report CSV generated by pipeline.py and summarizes results.
"""
import os
import pandas as pd
import sys
import re

# Assume these are available from the main pipeline file
CACHE_DIR = os.path.join(os.path.dirname(__file__), "data") 

def _safe_place_name(place: str) -> str:
    # Utility function to match the naming convention in pipeline.py
    return re.sub(r'[^0-9A-Za-z_\-\u0590-\u05FF]', '_', place)


def generate_full_report(place):
    """Loads the final diagnostic report and prints key metrics and examples."""
    if not place:
        print("ERROR: Please provide a place name as a command line argument (e.g., python diagnose_pipeline.py ×˜×‘×¨×™×”)")
        return
        
    chosen_place = place
    safe_place = _safe_place_name(chosen_place)
    
    report_path = os.path.join(CACHE_DIR, f"diagnostic_report_{safe_place}.csv")
    
    if not os.path.exists(report_path):
        print(f"\n--- âŒ ERROR: Diagnostic report not found at {report_path} ---")
        print(f"Please run the main pipeline first for '{chosen_place}' to generate the report file.")
        return

    print(f"\n--- Loading Diagnostic Report for {chosen_place} ---")
    # Load the CSV report
    df = pd.read_csv(report_path)
    
    # Fill NaN status for streets that didn't even make it to candidates_df
    df['status'] = df['status'].fillna('NO_CANDIDATES') 
    
    print("\n## ðŸ“Š Overall Matching Status Counts")
    print("-----------------------------------")
    print(df['status'].value_counts(dropna=False))
    
    # --- Matched Streets ---
    matched_df = df[df['final_LAMAS_id'].notna()].copy()
    
    print("\n## âœ… Successfully Matched Streets (Final LAMAS ID Assigned)")
    print(f"Total Successfully Matched: {matched_df.shape[0]}")
    
    confident_matches = matched_df[matched_df['status'] == 'CONFIDENT']
    ai_resolved_matches = matched_df[matched_df['status'] == 'NEEDS_AI']

    print(f"Total Confident Matches: {confident_matches.shape[0]}")
    print(f"Total AI-Resolved Matches: {ai_resolved_matches.shape[0]}")
    
    print("\n**Sample Confident Matches (Top 5):**")
    print(confident_matches
          [['osm_name', 'final_LAMAS_id', 'best_score', 'best_LAMAS_name']]
          .head(5).to_markdown(index=False))

    # --- Unmatched/Problematic Streets ---
    unmatched_df = df[df['final_LAMAS_id'].isna()].copy()
    
    print("\n## âŒ Unmatched / Ambiguous Streets (NEEDS_ATTENTION)")
    print(f"Total streets UNMATCHED (Final ID is empty): {unmatched_df.shape[0]}")
    
    missing_candidates = unmatched_df[unmatched_df['status'].isin(['MISSING', 'NO_CANDIDATES'])]
    ai_rejected = unmatched_df[unmatched_df['status'] == 'NEEDS_AI']
    
    print("\n**Sample Missing/No Candidates Streets (Top 5):**")
    print("> These require manual inspection. Name might be too different or street is new.")
    print(missing_candidates
          [['osm_name', 'normalized_name', 'city']]
          .head(5).to_markdown(index=False))

    print("\n**Sample Ambiguous (NEEDS_AI) But Unresolved Streets (Top 5):**")
    print("> Fuzzy match was ambiguous, and AI was skipped or returned 'None'.")
    # Use only relevant columns for unresolved AI cases
    print(ai_rejected
          [['osm_name', 'best_score', 'all_candidates']]
          .head(5).to_markdown(index=False))
    
    print("\n--- Diagnostic Report Complete ---")

if __name__ == "__main__":
    place_arg = None
    if len(sys.argv) > 1:
        place_arg = sys.argv[1]
    
    generate_full_report(place_arg)